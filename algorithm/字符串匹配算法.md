# 字符串匹配算法

## 朴素算法

字符模式匹配问题，我们第一想到的是暴力匹配方法，即遍历 S 的每个字符，以该字符为始与 P 比较，全部匹配就输出；否则直到 S 结束。
如果通过上述算法的时间复杂度为 O( nm) ，其中 n 为 S 的长度，m 为 P 的长度。这种时间复杂度很难满足我们的需求，接下来进入正题：时间复杂度为 Θ (n+m ) 的 KMP 算法。

## KMP 算法

Knuth-Morris-Pratt 字符串查找算法，简称为 “KMP 算法”，常用于在一个文本串 S 内查找一个模式串 P 的出现位置，这个算法由 Donald Knuth、Vaughan Pratt、James H. Morris 三人于 1977 年联合发表，故取这 3 人的姓氏命名此算法。

原理是：为了降低朴素算法的复杂度，让字符串 S 只遍历一遍，调整模式 P 的遍历位置。

### 算法流程如下（参考 [KMP 算法](https://juejin.im/entry/58edc67461ff4b006925d2e9)）

(1)
![kmp1](../images/kmp1.png?raw=true)

首先，主串 "BBC ABCDAB ABCDABCDABDE" 的第一个字符与模式串 "ABCDABD" 的第一个字符，进行比较。因为 B 与 A 不匹配，所以模式串后移一位。

(2)
![kmp2](../images/kmp2.png?raw=true)
因为 B 与 A 又不匹配，模式串再往后移。

(3)
![kmp3](../images/kmp3.png?raw=true)

因为 B 与 A 又不匹配，模式串再往后移。
就这样，直到主串有一个字符，与模式串的第一个字符相同为止。

(4)
![kmp4](../images/kmp4.png?raw=true)

接着比较主串和模式串的下一个字符，还是相同。

(5)
![kmp5](../images/kmp5.png?raw=true)

接着比较主串和模式串的下一个字符，还是相同。
直到主串有一个字符，与模式串对应的字符不相同为止。

(6)
![kmp6](../images/kmp6.png?raw=true)

这时，最自然的反应是，将模式串整个后移一位，再从头逐个比较。这样做虽然可行，但是效率很差，因为你要把 "搜索位置" 移到已经比较过的位置，重比一遍。

(7)
![kmp7](../images/kmp7.png?raw=true)

  一个基本事实是，当空格与 D 不匹配时，你其实知道前面六个字符是 "ABCDAB"。KMP 算法的想法是，设法利用这个已知信息，不要把 "搜索位置" 移回已经比较过的位置，而是继续把它向后移，这样就提高了效率。

(8)

| j | 0 | 1 | 2 | 3 | 4 | 5 | 6 | 7 |
| ------- | --- | --- | --- | --- | --- | --- | --- | ---- |
| 模式串 | A | B | C | D | A | B | D | '\0' |
| next[j] | -1 | 0 | 0 | 0 | 1 | 2 | 0 | 0 |

怎么做到这一点呢？可以针对模式串，设置一个跳转数组 int next[ ]，这个数组是怎么计算出来的，后面再介绍，这里只要会用就可以了。

(9)
![kmp8](../images/kmp8.png?raw=true)

已知空格与 D 不匹配时，前面六个字符 "ABCDAB" 是匹配的。根据跳转数组可知，不匹配处 D 的 next 值为 2，因此接下来从模式串下标为 2 的位置开始匹配。

（10）
![kmp9](../images/kmp9.png?raw=true)

因为空格与Ｃ不匹配，C 处的 next 值为 0，因此接下来模式串从下标为 0 处开始匹配。
（11）
![kmp10](../images/kmp10.png?raw=true)
因为空格与 A 不匹配，此处 next 值为 - 1，表示模式串的第一个字符就不匹配，那么直接往后移一位。
（12）
![kmp11](../images/kmp11.png?raw=true)

  逐位比较，直到发现 C 与 D 不匹配。于是，下一步从下标为 2 的地方开始匹配。
（13）
![kmp12](../images/kmp12.png?raw=true)

逐位比较，直到模式串的最后一位，发现完全匹配，于是搜索完成。

next 数组的求解基于 “前缀” 和“后缀”，即 next[j]等于 P[0]...P[j-1]最长的相同前后缀的长度（请暂时忽视 j 等于 0 时的情况，下面会有解释）。我们依旧以上述的表格为例，为了方便阅读，我复制在下方了。

| j       | 0   | 1   | 2   | 3   | 4   | 5   | 6   | 7    |
| ------- | --- | --- | --- | --- | --- | --- | --- | ---- |
| 模式串  | A   | B   | C   | D   | A   | B   | D   | '\0' |
| next[j] | -1  | 0   | 0   | 0   | 1   | 2   | 0   | 0    |

（1）j=0，对于模式串的首字符，我们统一为 next[0]=-1；
（2）j=1，前面的字符串为 A，其最长相同前后缀长度为 0，即 next[1]=0；
（3）j=2，前面的字符串为 AB，其最长相同前后缀长度为 0，即 next[2]=0；
（4）j=3，前面的字符串为 ABC，其最长相同前后缀长度为 0，即 next[3]=0；
（5）j=4，前面的字符串为 ABCD，其最长相同前后缀长度为 0，即 next[4]=0；
（6）j=5，前面的字符串为 ABCDA，其最长相同前后缀为 A，即 next[5]=1；
（7）j=6，前面的字符串为 ABCDAB，其最长相同前后缀为 AB，即 next[6]=2；
（8）j=7，前面的字符串为 ABCDABD，其最长相同前后缀长度为 0，即 next[7]=0。
   那么，为什么根据最长相同前后缀的长度就可以实现在不匹配情况下的跳转呢？举个代表性的例子：假如 j=6 时不匹配，此时我们是知道其位置前的字符串为 ABCDAB，仔细观察这个字符串，首尾都有一个 AB，既然在 j=6 处的 D 不匹配，我们为何不直接把 j=2 处的 C 拿过来继续比较呢，因为都有一个 AB 啊，而这个 AB 就是 ABCDAB 的最长相同前后缀，其长度 2 正好是跳转的下标位置。

### javascript 实现 KMP 算法

```js
class KMPString {
  constructor(str = "") {
    this.str = str;
  }
  /**
   * 获取莫需要匹配字符串的跳跃表
   * @param {String} pattern 需要匹配的字符串
   */
  _getNext(pattern) {
    let i = 0;
    let j = -1;
    const next = [];
    next[0] = -1;
    while (i < pattern.length) {
      // 当前位置相等，则继续往后匹配
      if (j == -1 || pattern[i] === pattern[j]) {
        i++;
        j++;
        next[i] = j;
      } else {
        // 找到需要匹配的位置
        j = next[j];
      }
    }
    return next;
  }
  /**
   * 返回匹配的位置
   * @param {String}} pattern 需要匹配的字符串
   */
  indexOf(pattern = "") {
    const next = this._getNext(pattern);
    let i = 0;
    let j = 0;
    while (i < this.str.length && j < pattern.length) {
      // 如果相等，则一直匹配下去
      if ((j === -1) | (this.str[i] === pattern[j])) {
        ++i;
        j++;
      } else {
        // 如果值不匹配，则获取下次匹配的位置
        j = next[j];
      }
    }
    if (j == pattern.length)
      // 匹配成功
      return i - j;

    return -1;
  }
}
```

### 时间复杂度

对于_getNext函数来说，若T的长度为m，因只涉及到简单的单循环，其时间复杂度为O(m)，而由于i值的不回溯，使得indexOf算法效率得到了提高，while循环的时间复杂度为O(n)。因此，整个算法的时间复杂度为O(n＋m)。相较于朴素模式匹配算法的O((n-m+1)*m)来说，是要好一些。